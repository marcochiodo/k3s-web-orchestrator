# Complete application example for KWO
# Includes: Registry Secret, Deployment, Service, Ingress with TLS, CronJob
#
# Usage:
#   1. Update registry credentials (if using private registry)
#   2. Update the image and host fields
#   3. kubectl apply -f app.yaml
#   4. kubectl get pods,svc,ingress

---
# Container Registry Credentials (optional)
# Uses environment variable placeholders for CI/CD integration.
# If using a private registry, set these environment variables:
#   - REGISTRY_SERVER (e.g., ghcr.io, docker.io)
#   - REGISTRY_USERNAME
#   - REGISTRY_PASSWORD
#
# Then deploy with: envsubst < app.yaml | kubectl apply -f -
#
# In GitHub Actions, set these as repository secrets and use:
#   env:
#     REGISTRY_SERVER: ghcr.io
#     REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
#     REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
#
# If using public images only, comment out this Secret and imagePullSecrets below.
apiVersion: v1
kind: Secret
metadata:
  name: registry-credentials
type: kubernetes.io/dockerconfigjson
stringData:
  .dockerconfigjson: |
    {
      "auths": {
        "${REGISTRY_SERVER}": {
          "username": "${REGISTRY_USERNAME}",
          "password": "${REGISTRY_PASSWORD}"
        }
      }
    }

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  labels:
    app: myapp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      # Use registry credentials if using private registry
      # Comment out this section if using public images
      imagePullSecrets:
        - name: registry-credentials
      containers:
        - name: myapp
          image: nginx:alpine  # Change to your image
          ports:
            - name: http
              containerPort: 80
          resources:
            requests:
              memory: "64Mi"
              cpu: "100m"
            limits:
              memory: "128Mi"
              cpu: "200m"
          livenessProbe:
            httpGet:
              path: /
              port: http
            initialDelaySeconds: 10
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /
              port: http
            initialDelaySeconds: 5
            periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: myapp
spec:
  type: ClusterIP
  selector:
    app: myapp
  ports:
    - port: 80
      targetPort: http

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: websecure
    traefik.ingress.kubernetes.io/router.tls: "true"
    # Choose cert resolver based on domain's DNS provider:
    # - letsencrypt-cloudflare (for Cloudflare domains)
    # - letsencrypt-ovh (for OVH domains)
    # - letsencrypt-route53 (for Route53 domains)
    # - letsencrypt-digitalocean (for DigitalOcean domains)
    traefik.ingress.kubernetes.io/router.tls.certresolver: letsencrypt-cloudflare
spec:
  rules:
    - host: myapp.example.com  # Change to your domain
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: myapp
                port:
                  number: 80

---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: myapp-backup
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  jobTemplate:
    spec:
      template:
        spec:
          containers:
            - name: backup
              image: curlimages/curl:latest
              command: ["/bin/sh", "-c"]
              args:
                - |
                  echo "Running backup..."
                  curl -X POST https://myapp.example.com/api/backup
              resources:
                requests:
                  memory: "32Mi"
                  cpu: "50m"
                limits:
                  memory: "64Mi"
                  cpu: "100m"
          restartPolicy: OnFailure
